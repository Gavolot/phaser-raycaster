{"version":3,"file":"phaser-raycaster.min.js","mappings":"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","sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/map/boundingBox.js","webpack://PhaserRaycaster/./src/map/config.js","webpack://PhaserRaycaster/./src/map/destroy.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/map/map-container-methods.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-matterBody-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-tilemap-methods.js","webpack://PhaserRaycaster/./src/map/segmentsCount.js","webpack://PhaserRaycaster/./src/ray/angle.js","webpack://PhaserRaycaster/./src/ray/cast.js","webpack://PhaserRaycaster/./src/ray/castCircle.js","webpack://PhaserRaycaster/./src/ray/castCone.js","webpack://PhaserRaycaster/./src/ray/cone.js","webpack://PhaserRaycaster/./src/ray/config.js","webpack://PhaserRaycaster/./src/ray/debug.js","webpack://PhaserRaycaster/./src/ray/destroy.js","webpack://PhaserRaycaster/./src/ray/enablePhysics.js","webpack://PhaserRaycaster/./src/ray/matter-physics-methods.js","webpack://PhaserRaycaster/./src/ray/origin.js","webpack://PhaserRaycaster/./src/ray/overlap.js","webpack://PhaserRaycaster/./src/ray/range.js","webpack://PhaserRaycaster/./src/ray/ray-core.js","webpack://PhaserRaycaster/./src/ray/ray.js","webpack://PhaserRaycaster/./src/ray/slice.js","webpack://PhaserRaycaster/./src/ray/stats.js","webpack://PhaserRaycaster/./src/raycaster-core.js","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/webpack/runtime/define property getters","webpack://PhaserRaycaster/webpack/runtime/hasOwnProperty shorthand","webpack://PhaserRaycaster/webpack/runtime/make namespace object","webpack://PhaserRaycaster/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(self, function() {\nreturn ","var PhaserRaycaster = function (scene)\n{\n    //The Scene that owns this plugin\n    this.scene = scene;\n\n    this.systems = scene.sys;\n\n    if (!scene.sys.settings.isBooted)\n    {\n        scene.sys.events.once('boot', this.boot, this);\n    }\n};\n\n//Static function called by the PluginFile Loader.\nPhaserRaycaster.register = function (PluginManager)\n{\n    //  Register this plugin with the PluginManager, so it can be added to Scenes.\n\n    //  The first argument is the name this plugin will be known as in the PluginManager. It should not conflict with already registered plugins.\n    //  The second argument is a reference to the plugin object, which will be instantiated by the PluginManager when the Scene boots.\n    //  The third argument is the local mapping. This will make the plugin available under `this.sys.base` and also `this.base` from a Scene if\n    //  it has an entry in the InjectionMap.\n    PluginManager.register('PhaserRaycaster', PhaserRaycaster, 'base');\n};\n\nPhaserRaycaster.prototype = {\n\n    //  Called when the Plugin is booted by the PluginManager.\n    //  If you need to reference other systems in the Scene (like the Loader or DisplayList) then set-up those references now, not in the constructor.\n    boot: function ()\n    {\n        var eventEmitter = this.systems.events;\n\n        //  Listening to the following events is entirely optional, although we would recommend cleanly shutting down and destroying at least.\n        //  If you don't need any of these events then remove the listeners and the relevant methods too.\n\n        eventEmitter.on('start', this.start, this);\n\n        eventEmitter.on('preupdate', this.preUpdate, this);\n        eventEmitter.on('update', this.update, this);\n        eventEmitter.on('postupdate', this.postUpdate, this);\n\n        eventEmitter.on('pause', this.pause, this);\n        eventEmitter.on('resume', this.resume, this);\n\n        eventEmitter.on('sleep', this.sleep, this);\n        eventEmitter.on('wake', this.wake, this);\n\n        eventEmitter.on('shutdown', this.shutdown, this);\n        eventEmitter.on('destroy', this.destroy, this);\n    },\n\n    //A test method.\n    test: function (name)\n    {\n        console.log('RaycasterPlugin says hello ' + name + '!');\n    },\n\n    //Called when a Scene is started by the SceneManager. The Scene is now active, visible and running.\n    start: function ()\n    {\n    },\n\n    //Called every Scene step - phase 1\n    preUpdate: function (time, delta)\n    {\n    },\n\n    //Called every Scene step - phase 2\n    update: function (time, delta)\n    {\n    },\n\n    //Called every Scene step - phase 3\n    postUpdate: function (time, delta)\n    {\n    },\n\n    //Called when a Scene is paused. A paused scene doesn't have its Step run, but still renders.\n    pause: function ()\n    {\n    },\n\n    //Called when a Scene is resumed from a paused state.\n    resume: function ()\n    {\n    },\n\n    //Called when a Scene is put to sleep. A sleeping scene doesn't update or render, but isn't destroyed or shutdown. preUpdate events still fire.\n    sleep: function ()\n    {\n    },\n\n    //Called when a Scene is woken from a sleeping state.\n    wake: function ()\n    {\n    },\n\n    //Called when a Scene shuts down, it may then come back again later (which will invoke the 'start' event) but should be considered dormant.\n    shutdown: function ()\n    {\n    },\n\n    //Called when a Scene is destroyed by the Scene Manager. There is no coming back from a destroyed Scene, so clear up all resources here.\n    destroy: function ()\n    {\n        this.shutdown();\n\n        this.scene = undefined;\n    },\n\n    //Create Raycaster object\n    createRaycaster: function(options = {}) {\n        options.scene = this.scene;\n        return new this._Raycaster(options);\n    }\n\n};\n\nPhaserRaycaster.prototype.constructor = PhaserRaycaster;\nPhaserRaycaster.prototype._Raycaster = require('./raycaster-core.js').Raycaster;\n\n//Make sure you export the plugin for webpack to expose\n\nmodule.exports = PhaserRaycaster;\n","/**\n* Get mapped object's bounding box.\n*\n* @method Raycaster.Map#matterBody.getBoundingBox\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Rectangle} - Mapped object's bounding box.\n*/\nexport function getBoundingBox() {\n    return this.object.getBounds();\n}\n","let rectangle = require('./map-rectangle-methods.js');\nlet line = require('./map-line-methods.js');\nlet polygon = require('./map-polygon-methods.js');\nlet arc = require('./map-circle-methods.js');\nlet container = require('./map-container-methods.js');\nlet tilemap = require('./map-tilemap-methods.js');\nlet matterBody = require('./map-matterBody-methods.js');\nlet segmentCount = require('./segmentsCount.js');\nlet boundingBox = require('./boundingBox.js');\n\n/**\n * Configure map.\n *\n * @method Raycaster.Map#config\n * @memberof Raycaster.Map\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - Map's congfiguration options. May include:\n * @param {object} options.object - Game object to map\n * @param {string} [options.type] - Map type. If not defined, it will be determined based on object.\n * @param {boolean} [options.dynamic = false] - If set true, map will be dynamic (updated on scene update event).\n * @param {boolean} [options.active = true] - If set true, map will be active (will provide points, segments and will be updated).\n * @param {integer} [options.segmentCount] - Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\n * @param {object} [options.mapChild] - Container's child. If set, only set child will be mapped.\n * @param {boolean} [options.forceConvex] - If set true, matter body map will use convex body (hull) for non-covex bodies.\n * @param {boolean} [options.forceVerticesMapping] - If set true, matter body map will use only vertices for mapping circle bodies.\n * \n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n */\nexport function config(options) {\n    this.object = options.object;\n    //object type\n    if(options.type === undefined)\n        options.type = options.object.type;\n    if(options.type === 'body' || options.type === 'composite')\n        options.type = 'MatterBody';\n    this.type = options.type;\n    \n    switch(options.type) {\n        case 'Polygon':\n            this.getPoints = polygon.getPoints;\n            this.getSegments = polygon.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = polygon.updateMap;\n            break;\n        case 'Arc':\n            //circle segments count\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\n            this.circle = (options.segmentCount) ? false : true;\n            this.getPoints = arc.getPoints;\n            this.getSegments = arc.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = arc.updateMap;\n            this.setSegmentCount = segmentCount.setSegmentCount;\n            break;\n        case 'Line':\n            this.getPoints = line.getPoints;\n            this.getSegments = line.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = line.updateMap;\n            break;\n        case 'Container':\n            //container's child\n            this.mapChild = (options.mapChild) ? options.mapChild : null;\n            //circle segments count\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\n            //transformed container's circle children\n            this._circles = [];\n            this.getPoints = container.getPoints;\n            this.getSegments = container.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = container.updateMap;\n            this._updateChildMap = container._updateChildMap;\n            this.setSegmentCount = segmentCount.setSegmentCount;\n            break;\n        case 'StaticTilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'DynamicTilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'TilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'MatterBody':\n            //force convex body (hull) mapping\n            this.forceConvex = (options.forceConvex) ? true : false;\n            //force mapping by vertices\n            this.forceVerticesMapping = (options.forceVerticesMapping) ? true : false;\n            this.circle = false;\n            this.getPoints = matterBody.getPoints;\n            this.getSegments = matterBody.getSegments;\n            this.getBoundingBox = matterBody.getBoundingBox;\n            this.updateMap = matterBody.updateMap;\n            break;\n        default:\n            this.getPoints = rectangle.getPoints;\n            this.getSegments = rectangle.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = rectangle.updateMap;\n    }\n\n    //dynamic map\n    this.dynamic = (options.dynamic == true) ? true : false;\n\n    //enable/disable map\n    this.active = (options.active !== undefined) ? options.active : true;\n\n    return this;\n}\n","/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Map#destroy\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    //destroy reference to map object in mapped object\r\n    if(this.object.type === 'body' || this.object.type === 'composite') {\r\n        delete object.raycasterMap;\r\n    }\r\n    else if(this.object.data) {\r\n        this.object.data.remove('raycasterMap');\r\n    }\r\n\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }","/*Map methods for circles*/\n/**\n* Get array of mapped circle's vertices used as rays targets.\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll calculatoe tangent points for passed ray.\n*\n* @method Raycaster.Map#arc.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n\n    if(this._points.length > 0)\n        return this._points;\n    \n    let points = [];\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\n\n    //calculate tangent rays\n    if(ray) {\n        let rayA = new Phaser.Geom.Line();\n        let rayB = new Phaser.Geom.Line();\n        let c;\n        \n        let rotation = this.object.rotation;\n        \n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            let cB = vector.getPointB();\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\n        }\n        else { \n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\n        }\n\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\n\n        //ray angle\n        let angle = Phaser.Geom.Line.Angle(c);\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n        //adding tangent points\n        points.push(rayA.getPointB());\n        points.push(rayB.getPointB());\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped circle's segments used to test object's intersection with ray.\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll return empty array.\n*\n* @method Raycaster.Map#arc.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update circles's map of points and segments.\n*\n* @method Raycaster.Map#arc.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    if(!this.segmentCount) {\n        this._points = [];\n        this._segments = [];\n        return this;\n    }\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\n\n    //get points surrounding circle\n    let points = this.object.geom.getPoints(this.segmentCount);\n    let segments = []\n\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let newPoints = [];\n        for(let point of points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            newPoints.push(vector.getPointB());\n        }\n        points = newPoints;\n    }\n    //if rotation === 0\n    else {\n        for(let point of points) {\n            point.x = point.x * this.object.scaleX + offset.x;\n            point.y = point.y * this.object.scaleY + offset.y;\n        }\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\n        else\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/*Map methods for containers*/\n/**\n* Get array of mapped container's and its children vertices used as rays targets.\n*\n* @method Raycaster.Map#container.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n* @param {bool} [isChild] - Flag definig if it is child container.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false, isChild = false) {\n    if(!this.active)\n        return [];\n\n    let points = this._points;\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    //get tangent points of container's circles\n    if(this.segmentCount == 0 && !isChild) {\n        if(ray) {\n            //create temporary ray\n            let vector = new Phaser.Geom.Line(0, 0, ray.origin.x - offset.x, ray.origin.y - offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) - this.object.rotation, Phaser.Geom.Line.Length(vector));\n    \n            let tempRay = ray._raycaster.createRay({\n                origin: {\n                    x: vector.getPointB().x,\n                    y: vector.getPointB().y\n                }\n            });\n\n            //calculate tangent rays\n            let rayA = new Phaser.Geom.Line();\n            let rayB = new Phaser.Geom.Line();\n            let c;\n\n            for(let circle of this._circles) {\n                circle.points = [];\n                c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, circle.x, circle.y);\n\n                let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(circle.radius, 2));\n\n                //ray angle\n                let angle = Phaser.Geom.Line.Angle(c);\n                let dAngle = Math.asin((circle.radius) / Phaser.Geom.Line.Length(c));\n                Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n                Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n                //adding tangent points\n                circle.points.push(rayA.getPointB());\n                circle.points.push(rayB.getPointB());\n                points.push(rayA.getPointB());\n                points.push(rayB.getPointB());\n            }\n        }\n    }\n    \n    return points;\n};\n\n/**\n* Get array of mapped container's and its children segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#container.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n\n    return this._segments;\n};\n\n/**\n* Update container's and its children maps of points and segments.\n*\n* @method Raycaster.Map#container.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    let container = this.object;\n    this._circles = [];\n\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    let rotation = container.rotation;\n\n    if(this.mapChild) {\n        this._updateChildMap(this.mapChild, points, segments, rotation, offset);\n    }\n    else {\n        //iterate through container's children\n        container.iterate(function(child){\n            this._updateChildMap(child, points, segments, rotation, offset);\n        }.bind(this));\n\n        //get children intersections\n        for(let i = 0, iLength = container.list.length; i < iLength; i++){\n            let childA = container.list[i];\n            let mapA = childA.data.get('raycasterMap');\n\n            for(let j = i+1, jLength = container.list.length; j < jLength; j++){\n                let childB = container.list[j];\n                let mapB = childB.data.get('raycasterMap');\n                //check if bounding boxes overlap\n                if(!Phaser.Geom.Intersects.RectangleToRectangle(childA.getBounds(), childB.getBounds()))\n                    continue;\n\n                //find objects intersections\n                for(let segmentA of mapA.getSegments()) {\n                    for(let segmentB of mapB.getSegments()) {\n                        let intersection = [];\n                        if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                            continue;\n                        \n                        //calculate positions after container's rotation\n                        if(rotation !== 0) {\n                            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, intersection.x * this.object.scaleX + offset.x, intersection.y * this.object.scaleY + offset.y);\n                            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                            points.push(vector.getPointB());\n                        }\n                        //if rotation === 0\n                        else\n                            points.push(new Phaser.Geom.Point(intersection.x * container.scaleX + offset.x, intersection.y * container.scaleX + offset.y));\n                    }\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n\n/**\n* Update container's child map of points and segments.\n*\n* @method Raycaster.Map#container._updateChildMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.10.3\n*\n* @param {object} [child] - Container's child object.\n* @param {Phaser.Geom.Point[]} [points] - Container's mapped points.\n* @param {Phaser.Geom.Line[]} [segments] - Container's mapped segments.\n* @param {float} [rotation] - Container's rotation.\n* @param {Phaser.Geom.Point} [offset] - Container's offset.\n*/\nexport function _updateChildMap(child, points, segments, rotation, offset) {\n    if(!child.data)\n        child.setDataEnabled();\n\n    //get child map\n    let map = child.data.get('raycasterMap');\n    if(!map) {\n        map = new this.constructor({\n            object: child,\n            segmentCount: this.segmentCount\n        });\n        child.data.set('raycasterMap', map);\n    }\n    else\n        map.updateMap();\n\n    //add child points\n    let childPoints = [];\n    for(let point of map.getPoints(false, true)) {\n        //calculate positions after container's rotation\n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            points.push(vector.getPointB());\n        }\n        //if rotation === 0\n        else\n            points.push(new Phaser.Geom.Point(point.x * container.scaleX + offset.x, point.y * container.scaleX + offset.y));\n\n        childPoints.push(points[points.length - 1])\n    }\n\n    //add child segments\n    for(let segment of map.getSegments()) {\n        //calculate positions after container's rotation\n        if(rotation !== 0) {\n            let pointA = segment.getPointA();\n            let pointB = segment.getPointB();\n            let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n            let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n            Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n\n            segments.push(new Phaser.Geom.Line(vectorA.getPointB().x, vectorA.getPointB().y, vectorB.getPointB().x, vectorB.getPointB().y));\n        }\n        //if rotation === 0\n        else\n            segments.push(new Phaser.Geom.Line(segment.getPointA().x * container.scaleX + offset.x, segment.getPointA().y * container.scaleY + offset.y, segment.getPointB().x * container.scaleX + offset.x, segment.getPointB().y * container.scaleY + offset.y));\n    }\n\n    //if child's map is a circle and this.segmentsCount == 0, store transformed circles in this._circles array.\n    if(map.type == 'Arc' && this.segmentCount == 0) {\n        let circleOffset = new Phaser.Geom.Point();\n        circleOffset.x = (map.object.x - map.object.displayWidth * (map.object.originX - 0.5)) * this.object.scaleX + offset.x;\n        circleOffset.y = (map.object.y - map.object.displayHeight * (map.object.originY - 0.5))  * this.object.scaleY + offset.y;\n\n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            circleOffset = vector.getPointB();\n        }\n\n        this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, map.object.radius * map.object.scaleX * this.object.scaleX));\n    }\n    else if(map.type === 'Container') {\n        for(let childMapCircle of map._circles) {\n            let circleOffset = new Phaser.Geom.Point();\n                circleOffset.x = childMapCircle.x * this.object.scaleX + offset.x;\n                circleOffset.y = childMapCircle.y * this.object.scaleY + offset.y;\n\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\n                Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                circleOffset = vector.getPointB();\n            }\n\n            this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, childMapCircle.radius * this.object.scaleX));\n        }\n    }\n}\n","/**\n * @classdesc\n *\n * Map class responsible for mapping game objects.\n *\n * @namespace Raycaster.Map\n * @class Raycaster.Map\n * @constructor\n * @since 6.0.0\n *\n * @param {object} options - Map specific configuration settings.\n * @param {Raycaster} [raycaster] - Parent raycaster object.\n */\nexport function Map(options, raycaster) {\n    /**\n    * Reference to parent Raycaster object.\n    *\n    * @name Raycaster.Map#_raycaster\n    * @type {Raycaster}\n    * @private\n    * @since 0.9.0\n    */\n    this._raycaster = raycaster ? raycaster : false;\n    /**\n    * Mapped object's type\n    *\n    * @name Raycaster.Map#type\n    * @type {string}\n    * @readonly\n    * @since 0.6.0\n    */\n    this.type;\n    /**\n    * If set true, map will be tested by ray. Otherwise it will be ignored.\n    *\n    * @name Raycaster.Map#active\n    * @type {boolean}\n    * @default true\n    * @since 0.7.2\n    */\n    this.active;\n    /**\n    * If set true, map will be automatically updated on scene update event.\n    *\n    * @name Raycaster.Map#dynamic\n    * @type {boolean}\n    * @default false\n    * @since 0.6.0\n    */\n    this.dynamic;\n    /**\n    * If set true, map will be treated by ray as circle. Set automaticalyy on map update.\n    *\n    * @name Raycaster.Map#circle\n    * @type {boolean}\n    * @default false\n    * @since 0.9.0\n    */\n    this.circle = false;\n    /**\n    * Reference to mapped object.\n    *\n    * @name Raycaster.Map#object\n    * @type {object}\n    * @readonly\n    * @since 0.6.0\n    */\n    this.object;\n    /**\n    * Array of mapped object's vertices used as rays targets.\n    *\n    * @name Raycaster.Map#_points\n    * @type {array}\n    * @private\n    * @since 0.6.0\n    */\n    this._points = [];\n    /**\n    * Array of mapped object's segments used to test object's intersection with ray.\n    *\n    * @name Raycaster.Map#_segments\n    * @type {array}\n    * @private\n    * @since 0.6.0\n    */\n    this._segments = [];\n    /**\n    * Get array of mapped object's vertices used as rays targets.\n    *\n    * @method Raycaster.Map#getPoints\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {Raycatser.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\n    *\n    * @return {Phaser.Geom.Point[]} Array of mapped object's vertices.\n    */\n    this.getPoints;\n    /**\n    * Get array of mapped object's segments used to test object's intersection with ray.\n    *\n    * @method Raycaster.Map#getSegments\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {Raycatser.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\n    *\n    * @return {Phaser.Geom.Line[]} Array of mapped object's segments.\n    */\n    this.getSegments;\n    /**\n    * Get mapped object's bounding box.\n    *\n    * @method Raycaster.Map#getBoundingBox\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.9.0\n    *\n    * @return {Phaser.Geom.Rectangle} Mapped object's bounding box.\n    */\n    this.getBoundingBox;\n    /**\n    * Update object's map of points and segments.\n    *\n    * @method Raycaster.Map#updateMap\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n    */\n    this.updateMap;\n\n    this.config(options);\n    this.updateMap();\n\n    return this;\n};\n\nMap.prototype = {\n    config: require('./config.js').config,\n    destroy: require('./destroy.js').destroy\n};\n\nMap.prototype.constructor = Map;\n","/*Map methods for lines*/\n/**\n* Get array of mapped line's vertices used as rays targets.\n*\n* @method Raycaster.Map#line.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped line's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#line.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update line's map of points and segments.\n*\n* @method Raycaster.Map#line.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    let pointA = this.object.geom.getPointA();\n    let pointB = this.object.geom.getPointB();\n\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n        pointA = vectorA.getPointB();\n\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n        pointB = vectorB.getPointB();\n\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\n    }\n    //if rotation === 0\n    else {\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y, pointB.x + offset.x * this.object.scaleX, pointB.y * this.object.scaleY + offset.y));\n    }\n    \n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/*Map methods for matter body*/\n/**\n* Get array of mapped matter body's vertices used as rays targets.\n*\n* @method Raycaster.Map#matterBody.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\n\n    //calculate tangent rays\n    if(ray && !this.forceVerticesMapping && body.circleRadius > 0) {\n        let points = [];\n        let rayA = new Phaser.Geom.Line();\n        let rayB = new Phaser.Geom.Line();\n        let c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, body.position.x, body.position.y);\n\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(body.circleRadius * body.scale.x, 2));\n\n        //ray angle\n        let angle = Phaser.Geom.Line.Angle(c);\n        let dAngle = Math.asin((body.circleRadius * body.scale.x) / Phaser.Geom.Line.Length(c));\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n        //adding tangent points\n        points.push(rayA.getPointB());\n        points.push(rayB.getPointB());\n\n        return points;\n    }\n\n    return this._points;\n};\n\n/**\n* Get array of mapped matter body's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#matterBody.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update matter body's map of points and segments.\n*\n* @method Raycaster.Map#matterBody.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\n    let bodies = [body];\n    let generateBounds = false;\n\n    if(body.circleRadius > 0 && !this.forceVerticesMapping) {\n        this.circle = true;\n        this._points = points;\n        this._segments = segments;\n\n        return this;\n    }\n\n    this.circle = false;\n\n    if(body.type == 'composite')\n        bodies = body.bodies;\n\n    if( ( body.bounds === undefined && body.type == 'composite' ) || ( body.type == 'composite' && this.dynamic ) ) {\n        generateBounds = true;\n    }\n    \n    for(let bodyItem of bodies) {\n        //if convex body\n        if(bodyItem.parts.length === 1 || this.forceConvex) {\n            let vertices = bodyItem.parts[0].vertices;\n\n            points.push(new Phaser.Geom.Point(vertices[0].x, vertices[0].y));\n\n            for(let i = 1, length = vertices.length; i < length; i++) {\n                let pointA = new Phaser.Geom.Point(vertices[i - 1].x, vertices[i - 1].y);\n                let pointB = new Phaser.Geom.Point(vertices[i].x, vertices[i].y);\n\n                points.push(pointB);\n\n                //add segment\n                let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n                segments.push(segment);\n            }\n\n            //closing segment\n            let segment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\n            segments.push(segment);\n        }\n\n        //if concave body\n        else if(bodyItem.parts.length > 1) {\n            for(let i = 1, length = bodyItem.parts.length; i < length; i++) {\n                let vertices = bodyItem.parts[i].vertices;\n                let pointA = new Phaser.Geom.Point(vertices[0].x, vertices[0].y);\n\n                if(points.find(point => point.x == pointA.x && point.y == pointA.y) === undefined)\n                    points.push(pointA);\n\n                for(let j = 1, length = vertices.length; j < length; j++) {\n                    let pointB = new Phaser.Geom.Point(vertices[j].x, vertices[j].y);\n                    //check if segment was already added\n                    let segmentIndex = segments.findIndex(segment => (segment.x1 == pointA.x && segment.y1 == pointA.y && segment.x2 == pointB.x && segment.y2 == pointB.y) || (segment.x1 == pointB.x && segment.y1 == pointB.y && segment.x2 == pointA.x && segment.y2 == pointA.y));\n                    \n                    if(segmentIndex !== -1) {\n                        segments.splice(segmentIndex, 1);\n                        pointA = pointB;\n                        continue;\n                    }\n                    \n                    if(points.find(point => point.x == pointB.x && point.y == pointB.y) === undefined)\n                        points.push(pointB);\n\n                    //add segment\n                    let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n                    segments.push(segment);\n                    \n                    pointA = pointB;\n                }\n                \n                //closing segment\n                let closingSegment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\n\n                let segmentIndex = segments.findIndex(segment => (segment.x1 == closingSegment.x1 && segment.y1 == closingSegment.y1 && segment.x2 == closingSegment.x2 && segment.y2 == closingSegment.y2) || (segment.x1 == closingSegment.x2 && segment.y1 == closingSegment.y2 && segment.x2 == closingSegment.x1 && segment.y2 == closingSegment.y1));\n                if(segmentIndex === undefined)\n                    segments.push(closingSegment);\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    if(generateBounds) {\n        let bounds = this._raycaster.scene.matter.composite.bounds(body);\n        body.bounds = bounds;\n    }\n\n    return this;\n};\n\n/**\n* Get matter body's bounding box.\n*\n* @method Raycaster.Map#matterBody.getBoundingBox\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Rectangle} - Matter body's bounding box.\n*/\nexport function getBoundingBox() {\n    let bounds = this.object.type === 'body' || this.object.type === 'composite' ? this.object.bounds : this.object.body.bounds;\n\n    return new Phaser.Geom.Rectangle(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);\n}\n\n","/*Map methods for polygons*/\n/**\n* Get array of mapped polygon's vertices used as rays targets.\n*\n* @method Raycaster.Map#polygon.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped polygon's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#polygon.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update polygon's map of points and segments.\n*\n* @method Raycaster.Map#polygon.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        for(let point of this.object.geom.points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            points.push(vector.getPointB());\n        }\n    }\n    //if rotation === 0\n    else {\n        for(let point of this.object.geom.points) {\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\n        }\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \n    }\n    //if polygon is closed\n    if(this.object.closePath) {\n        let last = points.length - 1;\n        segments.push(new Phaser.Geom.Line(points[last].x, points[last].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for rectangles*/\n/**\n* Get array of mapped rectangle's vertices used as rays targets.\n*\n* @method Raycaster.Map#rectangle.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped rectangle's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#rectangle.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update rectangle's map of points and segments.\n*\n* @method Raycaster.Map#rectangle.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n        \n    let points = [];\n    let segments = [];\n\n    //set points\n    points = [\n        this.object.getTopLeft(),\n        this.object.getTopRight(),\n        this.object.getBottomRight(),\n        this.object.getBottomLeft()\n    ];\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\n        else\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for tilemaps*/\n/**\n* Get array of mapped tilemap's vertices used as rays targets.\n*\n* @method Raycaster.Map#tilemap.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._points;\n\n    let points = [];\n    for(let point of this._points) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, point.x, point.y) <= ray.detectionRange)\n            points.push(point);\n    }\n\n    //get intersections between tilemap's segments and ray's detection range edge\n    let segments = this.getSegments(ray);\n\n    for(let segment of segments) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x1, segment.y1) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x1, segment.y1));\n        \n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x2, segment.y2) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x2, segment.y2));\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped tilemap's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#tilemap.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._segments;\n\n    let segments = [];\n    for(let segment of this._segments) {\n        if(Phaser.Geom.Intersects.LineToCircle(segment, ray.detectionRangeCircle)) {\n            segments.push(segment);\n        }\n    }\n\n    return segments;\n};\n\n/**\n* Update tilemap's map of points and segments.\n*\n* @method Raycaster.Map#tilemap.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x;\n    offset.y = this.object.y;\n\n    let horizontal = false;\n    let horizontals = [];\n    let verticals = [];\n\n    //iterate rows\n    for(let i = 0, iLength = this.object.layer.data.length; i < iLength; i++) {\n        let row = this.object.layer.data[i];\n\n        //iterate row's tiles\n        for(let j = 0, jLength = row.length; j < jLength; j++) {\n            let tile = row[j];\n\n            //check if tile and its top and left neighbours have different are from different sets (rays blocking and non-bloking)\n            let upperEdge = ((i > 0 && this.collisionTiles.includes(this.object.layer.data[i-1][j].index) != this.collisionTiles.includes(tile.index)) || (i == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\n            let leftEdge = ((j > 0 && this.collisionTiles.includes(this.object.layer.data[i][j-1].index) != this.collisionTiles.includes(tile.index)) || (j == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\n\n            //get current tile's column last vertical line\n            let vertical = false;\n            if(verticals.length <= j)\n                verticals[j] = [];\n            else if(verticals[j].length > 0)\n                vertical = verticals[j][verticals[j].length - 1];\n\n            //check if tile has edge from left\n            if(leftEdge) {\n                if(vertical && vertical.y + vertical.height == i)\n                    vertical.height++;\n                else {\n                    verticals[j].push({\n                        x: tile.x,\n                        y: tile.y,\n                        height: 1\n                    });\n                }\n            }\n\n            //check if tile has edge from top\n            if(upperEdge) {\n                if(horizontal)\n                    horizontal.width++;\n                else\n                    horizontal = {\n                        x: tile.x,\n                        y: tile.y,\n                        width: 1\n                    };\n                continue;\n            }\n\n            if(horizontal) {\n                let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n                let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n                let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n                segments.push(segment);\n                horizontals.push(segment);\n                points.push(new Phaser.Geom.Point(x, y));\n                points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n                horizontal = false;\n            }\n        }\n        \n        //at the end of row add segment if exist\n        if(horizontal) {\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n            segments.push(segment);\n            horizontals.push(segment);\n            points.push(new Phaser.Geom.Point(x, y));\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n            horizontal = false;\n        }\n    }\n\n    //add bottom horizontal segments\n    for(let tile of this.object.layer.data[this.object.layer.data.length - 1]) {\n        if(this.collisionTiles.includes(tile.index)) {\n            if(horizontal)\n                horizontal.width++;\n            else\n                horizontal = {\n                    x: tile.x,\n                    y: tile.y + 1,\n                    width: 1\n                };\n            continue;\n        }\n\n        if(horizontal) {\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n            segments.push(segment);\n            horizontals.push(segment);\n            points.push(new Phaser.Geom.Point(x, y));\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n            horizontal = false;\n        }\n    }\n\n    //add segment if exist\n    if(horizontal) {\n        let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n        let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n        let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n        segments.push(segment);\n        horizontals.push(segment);\n        points.push(new Phaser.Geom.Point(x, y));\n        points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n        horizontal = false;\n    }\n    \n    //add right vertical segments\n    let vertical = false;\n    let verticalsLastColumn = [];\n    for(let row of this.object.layer.data) {\n        let tile = row[row.length - 1];\n\n        //if tile blocks ray\n        if(this.collisionTiles.includes(tile.index)) {\n            if(vertical) {\n                vertical.height++;\n            }\n            else {\n                vertical = {\n                    x: tile.x + 1,\n                    y: tile.y,\n                    height: 1\n                };\n            }\n\n            continue;\n        }\n\n        if(vertical) {\n            verticalsLastColumn.push(vertical);\n            vertical = false;\n        }\n    }\n\n    verticals.push(verticalsLastColumn);\n    \n    //add vertical segments\n    for(let column of verticals) {\n        if(!column)\n            continue;\n\n        for(let vertical of column) {\n            let x = vertical.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y1 = vertical.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let y2 = y1 + this.object.layer.tileHeight * this.object.scaleY * vertical.height;\n            let segment = new Phaser.Geom.Line(x, y1, x, y2)\n            segments.push(segment);\n\n            //add points if they're not already there\n            if(!points.filter(point => point.x == x && point.y == y1))\n                points.push(new Phaser.Geom.Point(x, y));\n\n            if(!points.filter(point => point.x == x && point.y == y2))\n                points.push(new Phaser.Geom.Point(x, y));\n\n            //get intersections between horizontal segments and vertical\n            for(let horizontalSegment of horizontals) {\n                if(segment.x1 == horizontalSegment.x1 || segment.x1 == horizontalSegment.x2 || segment.x2 == horizontalSegment.x1 || segment.x2 == horizontalSegment.x2)\n                    continue;\n\n                if(segment.y1 == horizontalSegment.y1 || segment.y1 == horizontalSegment.y2 || segment.y2 == horizontalSegment.y1 || segment.y2 == horizontalSegment.y2)\n                    continue;\n\n                let point = new Phaser.Geom.Point();\n                if(Phaser.Geom.Intersects.LineToLine(segment, horizontalSegment, point)) {\n                    points.push(point);\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n\n/**\n* Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only).\n*\n* @method Raycaster.Map#setCollisionTiles\n* @memberof Raycaster.Map\n* @instance\n* @since 0.7.3\n*\n* @param {array} [tiles = []] - Set of tile's indexes to map.\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function setCollisionTiles(tiles = []) {\n    this.collisionTiles = tiles;\n    return this;\n}\n","/**\n * Set segment count for cirle's map.\n * If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\n *\n * @method Raycaster.Map#setSegmentCount\n * @memberof Raycaster.Map\n * @instance\n * @since 0.6.0\n *\n * @param {integer} count - Circle map's segment count.\n *\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n */\nexport function setSegmentCount(count) {\n    this.segmentCount = count;\n    this.circle = count ? false : true;\n\n    this.updateMap();\n    return this;\n}\n","/**\n * Set ray's angle (direction) in radians.\n *\n * @method Raycaster.Ray#setAngle\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {float} [angle = 0] - Ray's angle in radians.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setAngle(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n\n/**\n * Set ray's angle (direction) in degrees.\n *\n * @method Raycaster.Ray#setAngleDeg\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.1\n *\n * @param {float} [angle = 0] - Ray's angle in degrees.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setAngleDeg(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle));\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n","/**\n * Cast ray to find closest intersection with tested mapped objects.\n *\n * @method Raycaster.Ray#cast\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = {Raycaster#mappedObjects}] - Array of game objects to test. If not provided test all mapped game objects.\n * @param {Phaser.Geom.Point} [options.target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point.\n * @param {boolean} [options.internal = false] - Flag determining if method is used by other casting method.\n *\n * @return {(Phaser.Geom.Point|boolean)} Ray's closest intersection with tested objects. Returns false if no intersection has been found. Additionally contains reference to hit mapped object and segment if available.\n */\nexport function cast(options = {}) {\n    let closestIntersection;\n    let closestSegment;\n    let closestObject;\n    let closestDistance = this.rayRange;\n    let internal = options.internal ? options.internal : false;\n    let startTime = performance.now();\n    let stats = {\n        method: 'cast',\n        rays: 1,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //if bounding box is defined check bounding box intersection\n    if(this._raycaster && this._raycaster.boundingBox) {\n        let intersections = [];\n        Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\n        if(intersections.length === 1)\n            closestIntersection = intersections[0];\n        else if(intersections.length > 1) {\n            for(let intersection of intersections) {\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                if(distance < closestDistance) {\n                    closestDistance = distance;\n                    closestIntersection = intersection;\n                }\n            }\n        }\n        //if ray target is declared\n        else if(options.target){\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\n            //if target is within ray range\n            if(this.rayRange > distance) {\n                closestDistance = distance;\n                closestIntersection = options.target;\n            }\n        }\n    }\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n    \n    for(let object of options.objects) {\n        let map, boundingBox;\n        \n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        stats.testedMappedObjects++;\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        if(internal) {\n            boundingBox = map._boundingBox;\n        }\n        else {\n            boundingBox = map.getBoundingBox();\n            boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n        }\n\n        //check if object is intersected by ray\n        if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray, boundingBox).length === 0)\n            continue;\n\n        stats.hitMappedObjects++;\n        stats.segments += map.getSegments(this).length;\n        \n        //check intersections\n        for(let segment of map.getSegments(this)) {\n            let intersection = [];\n\n            //if target point is segmemt point\n            if(options.target) {\n                if(\n                    Phaser.Geom.Point.Equals(options.target, segment.getPointA())\n                    || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\n                ) {\n                    intersection = options.target;\n                }\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n                    continue;\n            }\n            //if no intersection continue\n            else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n              continue;\n            \n            //get closest intersection\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n            if(distance < closestDistance) {\n                closestDistance = distance;\n                closestIntersection = intersection;\n                closestObject = map.object;\n                closestSegment = segment;\n            }\n        }\n\n        //check if map is circular\n        if(map.circle) {\n           //if circular map has generated points (besides tangent points to ray)\n            if(map._points.length > 0) {\n                continue;\n            }\n            \n            //check if target point is a circle tangent point to ray\n            if(options.target) {\n                let points = map.getPoints(this);\n                let isTangent = false;\n                for(let point of points) {\n                    if(Phaser.Geom.Point.Equals(options.target, point)) {\n                        //get closest intersection\n                        let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\n\n                        if(distance < closestDistance) {\n                            closestDistance = distance;\n                            closestIntersection = point;\n                            closestObject = map.object;\n                            isTangent = true;\n                            break;\n                        }\n                    }\n                }\n\n                if(isTangent)\n                    continue;\n            }\n\n            let circleIntersections = [];\n            let offset = new Phaser.Geom.Point();\n            offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\n            offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\n\n            //calculate circle's center after rotation\n            let rotation = map.object.rotation;\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\n                Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                let cB = vector.getPointB();\n                offset.x = cB.x;\n                offset.y = cB.y;\n            }\n\n            //create transformed circle\n            let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\n\n            if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\n                for(let intersection of circleIntersections) {\n                    //get closest intersection\n                    let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\n\n                    if(distance < closestDistance) {\n\n                        closestDistance = distance;\n                        closestIntersection = intersection;\n                        closestObject = map.object;\n                    }\n                }\n            }\n        }\n\n        //check container map's circles\n        if(map.type == 'Container' && map._circles.length > 0) {\n            for(let circle of map._circles) {\n                //check if target point is a circle tangent point to ray\n                if(options.target) {\n                    let isTangent = false;\n\n                    for(let point of circle.points) {\n                        if(Phaser.Geom.Point.Equals(options.target, point)) {\n                            //get closest intersection\n                            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\n\n                            if(distance < closestDistance) {\n                                closestDistance = distance;\n                                closestIntersection = point;\n                                closestObject = map.object;\n                                isTangent = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if(isTangent)\n                        continue;\n                }\n\n                let circleIntersections = [];\n\n                if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\n                    for(let intersection of circleIntersections) {\n                        //get closest intersection\n                        let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\n\n                        if(distance < closestDistance) {\n                            closestDistance = distance;\n                            closestIntersection = intersection;\n                            closestObject = map.object;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    //update stats\n    if(internal) {\n        this._stats.rays++;\n        this._stats.testedMappedObjects += stats.testedMappedObjects;\n        this._stats.hitMappedObjects += stats.hitMappedObjects;\n        this._stats.segments += stats.segments;\n    }\n    else {\n        stats.time = performance.now() - startTime;\n        this._stats = stats;\n    }\n\n    let result;\n    if(!closestIntersection) {\n        if(this.ignoreNotIntersectedRays)\n            return false;\n\n        result = this._ray.getPointB();\n    }\n    else {\n        result = new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\n        result.segment = closestSegment;\n        result.object = closestObject;\n    }\n\n    if(this.round) {\n        result.x = Math.round(result.x);\n        result.y = Math.round(result.y);\n    }\n\n    if(!internal)\n        this.drawDebug([result]);\n    \n    return result;\n}","/**\n * Cast ray in all directions to find closest intersections with tested mapped objects.\n *\n * @method Raycaster.Ray#castCircle\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\n *\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\n */\nexport function castCircle(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n    let startTime = performance.now();\n    //reset stats\n    this._stats = {\n        method: 'castCircle',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n\n    //if bounding box is defined add bounding box points to \n    if(this._raycaster && this._raycaster.boundingBox) {\n        for(let point of this._raycaster.boundingBox.points) {\n            rayTargets.push({\n                point: point,\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n            });\n        }\n    }\n\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n        let object = options.objects[i];\n        //if bound in range\n        if(!this.boundsInRange(object))\n            continue;\n        \n        testedObjects.push(object);\n\n        let map, boundingBox;\n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        boundingBox = map.getBoundingBox();\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n\n        map._boundingBox = boundingBox;\n\n        maps.push(map);\n        //get points and angles\n        for(let point of map.getPoints(this)) {\n            rayTargets.push({\n                point: point,\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n            });\n        }\n\n        //get objects intersections\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n            let objectB = options.objects[j];\n            let mapB;\n            if(objectB.type === 'body' || objectB.type === 'composite')\n                mapB = objectB.raycasterMap;\n            else {\n                mapB = objectB.data.get('raycasterMap');\n            }\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\n                continue;\n            \n            //find objects intersections\n            for(let segmentA of map.getSegments(this)) {\n                for(let segmentB of mapB.getSegments(this)) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    \n                    rayTargets.push({\n                        point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                        angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\n                    });\n                }\n            }\n        }\n    }\n\n    //sort target points by angle\n    rayTargets.sort(function(a, b){\n        //if rays towards points have the same angles promote closer one\n        if(a.angle == b.angle) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                return 1;\n            else\n                return -1;\n        }\n\n        return a.angle - b.angle;\n    }.bind(this));\n\n    let previousTarget = {\n        angle: false\n    };\n\n    //cast rays\n    for(let target of rayTargets){\n        //if current target is the same as previous one skip loop\n        if(target.angle === previousTarget.angle) {\n            continue;\n        }\n\n        previousTarget = target;\n\n        this.setAngle(target.angle);\n        let intersection = this.cast({\n            objects: testedObjects,\n            target: target.point,\n            internal: true\n        });\n\n        if(intersection){\n            //if intersection hits target point cast two additional rays\n            let castSides = false;\n            if(this.round) {\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\n            }\n            else {\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\n            }\n            \n            if(castSides) {\n                this.setAngle(target.angle - 0.0001);\n                let intersectionA = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionA) {\n                    intersections.push(intersectionA);\n                }\n\n                intersections.push(intersection);\n\n                this.setAngle(target.angle + 0.0001);\n                let intersectionB = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionB) {\n                    intersections.push(intersectionB);\n                }\n\n                continue;\n            }\n\n            intersections.push(intersection);\n        }\n    }\n\n    this.setAngle(originalAngle);\n    this.intersections = intersections;\n\n    if(this.autoSlice)\n        this.slicedIntersections = this.slice();\n\n    this._stats.time = performance.now() - startTime;\n\n    this.drawDebug(intersections);\n\n    return intersections;\n}\n","/**\n * Cast ray in a cone to find closest intersections with tested mapped objects.\n *\n * @method Raycaster.Ray#castCone\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\n *\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\n */\nexport function castCone(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n    let cone = this.cone;\n    let minAngle = 0;\n    let maxAngle = 0;\n    let angleOffset = 0;\n    let startTime = performance.now();\n    //reset stats\n    this._stats = {\n        method: 'castCone',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //set cone\n    if(options.cone !== undefined)\n        cone = options.cone;\n    if(options.coneDeg !== undefined)\n        cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //set cone min and max angle\n    minAngle = this.angle - cone / 2;\n    maxAngle = this.angle + cone / 2;\n\n    //add min and max angle points\n    this.setAngle(minAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: minAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2)\n    });\n\n    this.setAngle(maxAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: maxAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2)\n    });\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n\n    //if bounding box is defined add bounding box points to \n    if(this._raycaster && this._raycaster.boundingBox) {\n        for(let point of this._raycaster.boundingBox.points) {\n\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                rayTargets.push({\n                    point: point,\n                    angle: angle,\n                    angleOffsetDeg: -angleOffsetDeg\n                });\n            }\n        }\n    }\n\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n        let object = options.objects[i];\n        //if bound in range\n        if(!this.boundsInRange(object))\n            continue;\n        \n        testedObjects.push(object);\n\n        let map, boundingBox;\n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        boundingBox = map.getBoundingBox();\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n\n        map._boundingBox = boundingBox;\n\n        maps.push(map);\n        //get points and angles\n        for(let point of map.getPoints(this)) {\n\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y),\n                    angleOffsetDeg: -angleOffsetDeg\n                });\n            }\n        }\n\n        //get objects intersections\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n            let objectB = options.objects[j];\n            let mapB;\n            if(objectB.type === 'body' || objectB.type === 'composite')\n                mapB = objectB.raycasterMap;\n            else\n                mapB = objectB.data.get('raycasterMap');\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\n                continue;\n            \n            //find objects intersections\n            for(let segmentA of map.getSegments(this)) {\n                for(let segmentB of mapB.getSegments(this)) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                    let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n                    if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                        rayTargets.push({\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y),\n                            angleOffsetDeg: -angleOffsetDeg\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    //sort target points by angle\n    rayTargets.sort(function(a, b){\n        //if rays towards points have the same angles promote closer one\n        if(a.angle == b.angle) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                return 1;\n            else\n                return -1;\n        }\n\n        return a.angleOffsetDeg - b.angleOffsetDeg;\n    }.bind(this));\n\n    let previousTarget = {\n        angle: false\n    };\n\n    //cast rays\n    for(let target of rayTargets){\n        //if current target is the same as previous one skip loop\n        if(target.angle === previousTarget.angle) {\n            continue;\n        }\n\n        previousTarget = target;\n        \n        this.setAngle(target.angle);\n        let intersection = this.cast({\n            objects: testedObjects,\n            target: target.point,\n            internal: true\n        });\n        if(intersection){\n            //if intersection hits target point cast two additional rays\n            let castSides = false;\n            if(this.round) {\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\n            }\n            else {\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\n            }\n            if(castSides) {\n                this.setAngle(target.angle - 0.0001);\n                let intersectionA = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionA) {\n                    intersections.push(intersectionA);\n                }\n\n                intersections.push(intersection);\n\n                this.setAngle(target.angle + 0.0001);\n                let intersectionB = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionB) {\n                    intersections.push(intersectionB);\n                }\n\n                continue;\n            }\n\n            intersections.push(intersection);\n        }\n    }\n\n    this.setAngle(originalAngle);\n    this.intersections = intersections;\n    if(this.autoSlice)\n        this.slicedIntersections = this.slice(intersections, false);\n    \n    this._stats.time = performance.now() - startTime;\n\n    this.drawDebug(intersections);\n\n    return intersections;\n}\n","/**\n * Set ray's cone angle (width) in radians.\n *\n * @method Raycaster.Ray#setCone\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {float} [cone = 0] - Ray's cone angle in radians.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCone(cone = 0) {\n    this.cone = cone;\n    return this;\n}\n\n/**\n * Set ray's cone angle (width) in degrees.\n *\n * @method Raycaster.Ray#setConeDeg\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {float} [cone = 0] - Ray's cone angle in degrees.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setConeDeg(cone = 0) {\n    this.cone = Phaser.Math.DegToRad(cone);\n    return this;\n}\n","/**\n * Configure ray.\n *\n * @method Raycaster.Ray#config\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - Ray's congfiguration options. May include:\n * @param {Phaser.Geom.Point} [options.origin = {x:0, y:0}] - Ray's position.\n * @param {float} [options.angle = 0] - Ray's angle in radians.\n * @param {float} [options.angleDeg = 0] - Ray's angle in degrees.\n * @param {float} [options.cone = 0] - Ray's cone angle in radians.\n * @param {float} [options.coneDeg = 0] - Ray's cone angle in degrees.\n * @param {integer} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n * @param {integer} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\n * @param {integer} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function config(options) {\n    this.object = options.object;\n    //origin\n    if(options.origin !== undefined)\n        this.origin.setTo(options.origin.x, options.origin.y);\n\n    //angle\n    if(options.angle !== undefined)\n        this.angle = Phaser.Math.Angle.Normalize(options.angle);\n\n    //angle deg\n    if(options.angleDeg !== undefined)\n        this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg));\n\n    //cone angle\n    if(options.cone !== undefined)\n        this.cone = options.cone;\n\n    //cone angle deg\n    if(options.coneDeg !== undefined)\n        this.cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //ray range (0 = max)\n    if(options.rayRange !== undefined)\n        this.rayRange = options.rayRange;\n\n    //collision range (0 = max)\n    if(options.collisionRange !== undefined)\n        this.collisionRange = options.collisionRange;\n\n    //detection range (0 = max)\n    if(options.detectionRange !== undefined)\n        this.detectionRange = options.detectionRange;\n\n    //ignore not intersected rays\n    if(options.ignoreNotIntersectedRays !== undefined)\n        this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\n    \n    //round\n    if(options.round !== undefined)\n        this.round = (options.round == true)\n\n    //auto slice\n    if(options.autoSlice !== undefined)\n        this.autoSlice = (options.autoSlice == true)\n\n    //enable physics\n    if(options.enablePhysics !== undefined && options.enablePhysics)\n        this.enablePhysics(options.enablePhysics);\n    \n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    if(this._raycaster.debugOptions.enabled && this._raycaster.scene !== undefined) {\n        this.graphics =  this._raycaster.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\n        this.graphics.setDepth(1000);\n    }\n\n    return this;\n}\n","/**\r\n * Draw rays in debug mode\r\n *\r\n * @method Raycaster.Ray#drawDebug\r\n * @memberof Raycaster\r\n * @private\r\n * @since 0.10\r\n * \r\n * @param {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function drawDebug(intersections) {\r\n    if(this.graphics === undefined || !this._raycaster.debugOptions.enabled)\r\n        return this;\r\n\r\n    //clear\r\n    this.graphics.clear();\r\n\r\n    if(!this._raycaster.debugOptions.rays)\r\n        return this;\r\n    \r\n    if(this._raycaster.debugOptions.graphics.ray) {\r\n        this.graphics.lineStyle(1, this._raycaster.debugOptions.graphics.ray);\r\n\r\n        for(let intersection of intersections) {\r\n            this.graphics.strokeLineShape({\r\n                x1: this.origin.x,\r\n                y1: this.origin.y,\r\n                x2: intersection.x,\r\n                y2: intersection.y\r\n            });\r\n        }\r\n    }\r\n\r\n    if(this._raycaster.debugOptions.graphics.rayPoint) {\r\n        this.graphics.fillStyle(this._raycaster.debugOptions.graphics.rayPoint);\r\n\r\n        this.graphics.fillPoint(this.origin.x, this.origin.y, 3);\r\n        \r\n        for(let intersection of intersections) {\r\n            this.graphics.fillPoint(intersection.x, intersection.y, 3);\r\n        }\r\n    }\r\n\r\n    return this;\r\n}","/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Ray#destroy\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }","/**\n * Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. Physics body can be added only once.\n *\n * @method Raycaster.Ray#enablePhysics\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {'arcade'|'matter'} [type = 'arcade'] - Physics type\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function enablePhysics(type = 'arcade') {\n    \n    if(this.body !== undefined)\n        return this;\n\n    this.collisionCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y, this.collisionRange);\n    this.collisionCircle._ray = this;\n\n    if(type === 'matter') {\n        this.bodyType = 'matter';\n\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\n            let bounds = this._raycaster.boundingBox;\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'rectangle', x:bounds.rectangle.centerX, y:bounds.rectangle.centerY, width:bounds.rectangle.width, height:bounds.rectangle.height }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\n        }\n        else {\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'circle' }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\n        }\n\n        this.body = this.collisionCircle.body;\n        this.body._ray = this;\n        this.setOnCollideActive();\n    }\n    else {\n        this.bodyType = 'arcade';\n        this._raycaster.scene.physics.add.existing(this.collisionCircle);\n\n        this.body = this.collisionCircle.body;\n        this.body\n            .setCircle(this.collisionRange)\n            .setAllowGravity(false)\n            .setImmovable(true);\n        this.body._ray = this;\n    }\n\n    return this;\n}\n","/*Matter physics methods for ray body*/\n/**\n * Sets the collision category of this ray's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31.\n * Two bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision\n * categories are included in their collision masks (see {@link #setCollidesWith}).\n *\n * @method Raycaster.Ray#setCollisionCategory\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {number} value - Unique category bitfield.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionCategory(value) {\n    this.body.collisionFilter.category = value;\n\n    return this;\n};\n\n/**\n * Sets the collision group of this ray's Matter Body. If this is zero or two Matter Bodies have different values,\n * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).\n * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value,\n * they will never collide.\n *\n * @method Raycaster.Ray#setCollisionCategory\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {number} value - Unique group index.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionGroup(value) {\n    this.body.collisionFilter.group = value;\n\n    return this;\n};\n\n/**\n * Sets the collision mask for this ray's Matter Body. Two Matter Bodies with different collision groups will only\n * collide if each one includes the other's category in its mask based on a bitwise AND, i.e. `(categoryA & maskB) !== 0`\n * and `(categoryB & maskA) !== 0` are both true.*\n *\n * @method Raycaster.Ray#setCollidesWith\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {(number|number[])} categories - A unique category bitfield, or an array of them.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\n\nexport function setCollidesWith(categories) {\n    var flags = 0;\n\n    if (!Array.isArray(categories))\n    {\n        flags = categories;\n    }\n    else\n    {\n        for (var i = 0; i < categories.length; i++)\n        {\n            flags |= categories[i];\n        }\n    }\n\n    this.body.collisionFilter.mask = flags;\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollide\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke when this body starts colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollide(callback) {\n    let self = this;\n    this.body.onCollideCallback = function(collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            callback(collisionInfo);\n        }\n        else if(self.processOverlap(collisionInfo)) {\n            collisionInfo.rayCollided = true;\n            callback(collisionInfo);\n        }\n    };\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideEnd\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke when this body stops colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideEnd(callback) {\n    this.body.onCollideEndCallback = function(collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            collisionInfo.rayCollided = false;\n            callback(collisionInfo);\n        }\n    }\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideActive\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke for the duration of this body colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideActive(callback) {\n    let self = this;\n    let func = function(collisionInfo) {\n        if(self.processOverlap(collisionInfo)) {\n            let body = collisionInfo.bodyA.label === 'phaser-raycaster-ray-body' ? collisionInfo.bodyB : collisionInfo.bodyA;\n\n            if(collisionInfo.rayCollided !== true) {\n                collisionInfo.rayCollided = true;\n                if(self.body.onCollideCallback) {\n                    self.body.onCollideCallback(collisionInfo);\n                }\n\n                if(self.body.onCollideWith !== undefined && self.body.onCollideWith[body.id]) {\n                    self.body.onCollideWith[body.id](body, collisionInfo);\n                }\n            }\n            if(callback)\n                callback(collisionInfo);\n        }\n        else {\n            if(self.body.onCollideEndCallback && collisionInfo.rayCollided === true) {\n                self.body.onCollideEndCallback(collisionInfo);\n            }\n        }\n    }\n\n    this.body.onCollideActiveCallback = func;\n\n    return this;\n}\n\n/**\n * The callback is sent a reference to the other body, along with a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideWith\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {(MatterJS.Body|MatterJS.Body[])} body - The body, or an array of bodies, to test for collisions with.\n * @param {function} callback - The callback to invoke when this body collides with the given body or bodies.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideWith(body, callback) {\n    let self = this;\n    let func = function(body, collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            callback(body, collisionInfo);\n        }\n        else if(self.processOverlap(collisionInfo)) {\n            collisionInfo.rayCollided = true;\n            callback(body, collisionInfo);\n        }\n    }\n\n    if (!Array.isArray(body))\n    {\n        body = [ body ];\n    }\n\n    for (var i = 0; i < body.length; i++)\n    {\n        var src = (body[i].hasOwnProperty('body')) ? body[i].body : body[i];\n\n        this.body.setOnCollideWith(src, func);\n    }\n\n    return this;\n};\n","/**\n * Set ray's source position.\n *\n * @method Raycaster.Ray#setOrigin\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} x - X coordinate.\n * @param {integer} y - Y coordinate.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOrigin(x, y) {\n    this.origin.setTo(x, y);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    if(this.bodyType === 'matter' && this.collisionRange !== Phaser.Math.MAX_SAFE_INTEGER) {\n        this.collisionCircle.x = x;\n        this.collisionCircle.y = y;\n    }\n    else if(this.bodyType === 'arcade') {\n        this.collisionCircle.x = x;\n        this.collisionCircle.y = y;\n    }\n\n    return this;\n}\n","/**\n * Get game objects overlaping field of view.\n *\n * @method Raycaster.Ray#overlap\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {object|object[]} [objects] - Game object / array off game objects to test.\n *\n * @return {object[]} Array of game objects that overlaps with field of view.\n */\nexport function overlap(objects) {\n    let targets = [];\n    let overlapCircle = new Phaser.Geom.Circle(this.origin.x, this.origin.y, this.collisionRange);\n\n    //matter physics\n    if(this.bodyType === 'matter') {\n        let isCollisionInfo = false;\n        if(objects === undefined) {\n            objects = this._raycaster.scene.matter.query.collides(this.body, this._raycaster.scene.matter.getMatterBodies());\n\n            for(let object of objects) {   \n                let body = object.bodyA === this.body ? object.bodyB : object.bodyA;\n\n                if(this.testMatterOverlap(body))\n                    targets.push(body);\n            }\n        }\n        //get object's body\n        else {\n            if(!Array.isArray(objects))\n                objects = [objects];\n            \n            for(let object of objects) {\n                if(object === this.body)\n                    continue;\n    \n                if(this.testMatterOverlap(object))\n                    targets.push(object);\n            }\n        }\n    }\n    //arcade physics\n    else {\n        let bodies = false;\n        //get bodies in range\n        if(objects === undefined) {\n            objects = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, true, true);\n            bodies = true;\n        }\n        //get object's body\n        else if(!Array.isArray(objects)) {\n            objects = [objects];\n        }\n        //if objects are bodies\n        if(bodies) {\n            for(let body of objects) {\n                if(body === this.body)\n                    continue;\n            \n                let hitbox;\n                //get physics body hitbox\n                if(body.isCircle) {\n                    hitbox = new Phaser.Geom.Circle(body.position.x + body.halfWidth, body.position.y + body.halfWidth, body.halfWidth);\n                }\n                else {\n                    hitbox = new Phaser.Geom.Rectangle(body.x, body.y, body.width, body.height);\n                }\n\n                if(this.testArcadeOverlap(hitbox))\n                    targets.push(body.gameObject);\n            }\n        }\n        //if objects are game objects\n        else {\n            for(let object of objects) {\n                if(object.body === undefined)\n                    continue;\n\n                let hitbox;\n                //get physics body hitbox\n                if(object.body.isCircle) {\n                    hitbox = new Phaser.Geom.Circle(object.body.position.x + object.body.halfWidth, object.body.position.y + object.body.halfWidth, object.body.halfWidth);\n                    if(!Phaser.Geom.Intersects.CircleToCircle(overlapCircle, hitbox))\n                        continue;\n                }\n                else {\n                    hitbox = new Phaser.Geom.Rectangle(object.body.x, object.body.y, object.body.width, object.body.height);\n                    if(!Phaser.Geom.Intersects.CircleToRectangle(overlapCircle, hitbox))\n                        continue;\n                }\n\n                if(this.testArcadeOverlap(hitbox))\n                    targets.push(object);\n            }\n        }\n    }\n\n    return targets;\n}\n\n/**\n * Process callback for physics collider / overlap.\n *\n * @method Raycaster.Ray#processOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {object} object1 - Game object or matter body passed by collider / overlap or matter CollisionInfo object.\n * @param {object} object2 - Game object or matter body passed by collider / overlap. Ignored if matter CollisionInfo object was passed as first argument.\n *\n * @return {boolean} Return true if game object is overlapping ray's field of view.\n */\nexport function processOverlap(object1, object2) {\n    let obj1, obj2, target;\n    //check if it's matter collisionInfo object\n    if(object1.bodyA !== undefined && object1.bodyB !== undefined) {\n        obj1 = object1.bodyA;\n        obj2 = object1.bodyB;\n    }\n    else {\n        obj1 = object1;\n        obj2 = object2;\n    }\n\n    if(obj1._ray !== undefined && obj1._ray === this)\n        target = obj2;\n    else if(obj2._ray !== undefined && obj2._ray === this)\n        target = obj1;\n    else\n        return false;\n\n    return (this.overlap(target).length > 0);\n}   \n\n/**\n * Test if hitbox overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @method Raycaster.Ray#testArcadeOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @private\n * @since 0.8.0\n *\n * @param {object} hitbox - Game object's hitbox generated inside {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @return {boolean} True if hitbox overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\n */\nexport function testArcadeOverlap(hitbox) {\n    let overlap = false;\n\n    //iterate through field of view slices to check collisions with target\n    for(let slice of this.slicedIntersections) {\n        //if hitbox is a circle\n        if(hitbox.type == 0) {\n            overlap = Phaser.Geom.Intersects.TriangleToCircle(slice, hitbox);\n        }\n        //if hitbox is a rectangle\n        else {\n            overlap = Phaser.Geom.Intersects.RectangleToTriangle(hitbox, slice);\n        }\n\n        if(overlap) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Test if matter body overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @method Raycaster.Ray#testMatterOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @private\n * @since 0.9.0\n *\n * @param {object} body - Matter body.\n *\n * @return {boolean} True if body overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\n */\nexport function testMatterOverlap(object) {\n    let body;\n\n    if(object.type === 'body')\n        body = object;\n    else if(object.body !== undefined)\n        body = object.body;\n    else\n        return false;\n\n    //if body is concave, ignore convex body\n    let parts = body.parts.length > 1 ? body.parts.splice(1) : body.parts;\n    //iterate through bodies\n    for(let part of parts) {\n        let pointA = part.vertices[0];\n\n        for(let i = 1, length = part.vertices.length; i < length; i++) {\n            let pointB = part.vertices[i];\n            let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n\n            //iterate through field of view slices to check collisions with target\n            for(let slice of this.slicedIntersections) {\n                let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\n                //additional checking if slice contain segment's points due to TriangleToLine bug.\n                if(!overlap)\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointA());\n                if(!overlap)\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointB());\n\n                if(overlap) {\n                    return true;\n                }\n            }\n            pointA = pointB;\n        }\n\n        //closing segment\n        let segment = new Phaser.Geom.Line(part.vertices[part.vertices.length - 1].x, part.vertices[part.vertices.length - 1].y, part.vertices[0].x, part.vertices[0].y);\n         //iterate through field of view slices to check collisions with target\n        for(let slice of this.slicedIntersections) {\n            let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\n\n            if(overlap) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n","/**\n * Set ray's range.\n *\n * @method Raycaster.Ray#setRayRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} [rayRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setRayRange(rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.rayRange = rayRange;\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n\n/**\n * Set ray's maximum detection range. Objects outside detection range won't be tested.\n * Ray tests all objects when set to 0.\n *\n * @method Raycaster.Ray#setDetectionRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} [detectionRange = 0] - Maximum distance between ray's position and tested objects bounding boxes.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setDetectionRange(detectionRange = 0) {\n    this.detectionRange = detectionRange;\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    return this;\n}\n\n/**\n * Set ray's field of view maximum collision range. Objects outside collision range won't be tested by {@link Raycaster.Ray#overlap Raycaster.Ray.overlap} method.\n * Determines ray's physics body radius.\n *\n * @method Raycaster.Ray#setCollisionRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {integer} [collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's collision range and physics body radius.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionRange(collisionRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    let oldRangeMax = this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER;\n    this.collisionRange = collisionRange;\n    this.collisionCircle.setRadius(this.collisionRange);\n\n    if(this.bodyType === 'matter') {\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\n            let bounds = this._raycaster.boundingBox;\n\n            this._raycaster.scene.matter.body.set(this.body, {\n                shape: {\n                    type: 'rectangle',\n                    x: bounds.rectangle.centerX,\n                    y: bounds.rectangle.centerY,\n                    width: bounds.rectangle.width,\n                    height: bounds.rectangle.height,\n                    circleRadius:0\n                }\n            });\n        }\n        else if(oldRangeMax) {\n            this._raycaster.scene.matter.body.set(this.body, {\n                shape: {\n                    type: 'circle',\n                    x: this.collisionCircle.x,\n                    y: this.collisionCircle.y\n                },\n                circleRadius: this.collisionRange,\n                isStatic: false\n            });\n        }\n        else {\n            this.collisionCircle.setRadius(this.collisionRange);\n        }\n        this._raycaster.scene.matter.body.set(this.body, 'circleRadius', this.collisionRange)\n    }\n    else if(this.bodyType === 'arcade') {\n        this.body.setCircle(this.collisionRange);\n    }\n\n    return this;\n}\n\n/**\n * Test if object's bounding box is in ray's detection range.\n *\n * @method Raycaster.Ray#boundsInRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} object - Tested object\n * @param {(Phaser.Geom.Rectangle|boolean)} [bounds = false] - Tested object's bounds. If not passed bounds will be generated automatically.\n *\n * @return {boolean} Information if object is in ray's detection range.\n */\nexport function boundsInRange(object, bounds = false) {\n    if(!this.detectionRange)\n        return true;\n\n    let objectBounds;\n    if(bounds)\n        objectBounds = bounds;\n    else {\n        if(object.type === 'body' || object.type === 'composite')\n            objectBounds = object.raycasterMap.getBoundingBox();\n        else\n            objectBounds = object.data.get('raycasterMap').getBoundingBox();\n    }\n\n    if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\n        return true;\n\n    return false;\n}\n","/**\n * @classdesc\n *\n * Ray class responsible for casting ray's and testing their collisions with mapped objects.\n *\n * @namespace Raycaster.Ray\n * @class Raycaster.Ray\n * @constructor\n * @since 6.0.0\n *\n * @param {object} options - Ray specific configuration settings.\n * @param {Raycaster} [raycaster] - Parent raycaster object.\n */\nexport function Ray(options, raycaster) {\n    /**\n    * Reference to parent Raycaster object.\n    *\n    * @name Raycaster.Ray#_raycaster\n    * @type {Raycaster}\n    * @private\n    * @since 0.6.0\n    */\n    this._raycaster = raycaster ? raycaster : false;\n    /**\n    * Ray's source position.\n    *\n    * @name Raycaster.Ray#origin\n    * @type {Phaser.Geom.Point}\n    * @since 0.6.0\n    */\n    this.origin = new Phaser.Geom.Point();\n    /**\n    * Ray's representation used to calculating intersections.\n    *\n    * @name Raycaster.Ray#_ray\n    * @type {Phaser.Geom.Line}\n    * @private\n    * @since 0.6.0\n    */\n    this._ray = new Phaser.Geom.Line();\n    /**\n    * Ray's angle in radians.\n    *\n    * @name Raycaster.Ray#angle\n    * @type {float}\n    * @default 0\n    * @since 0.6.0\n    */\n    this.angle = 0;\n    /**\n    * Ray's cone width angle in radians.\n    *\n    * @name Raycaster.Ray#cone\n    * @type {float}\n    * @default 0\n    * @since 0.7.0\n    */\n    this.cone = 0;\n    /**\n    * Ray's maximum range\n    *\n    * @name Raycaster.Ray#rayRange\n    * @type {integer}\n    * @default Phaser.Math.MAX_SAFE_INTEGER\n    * @since 0.6.0\n    */\n    this.rayRange = Phaser.Math.MAX_SAFE_INTEGER;\n    /**\n    * Ray's maximum detection range. Objects outside detection range won't be tested.\n    * Ray tests all objects when set to 0.\n    *\n    * @name Raycaster.Ray#detectionRange\n    * @type {integer}\n    * @default\n    * @since 0.6.0\n    */\n    this.detectionRange = 0;\n    /**\n    * Ray's representation of detection range used in calculating if objects are in range.\n    *\n    * @name Raycaster.Ray#detectionRangeCircle\n    * @type {Phaser.Geom.Circle}\n    * @private\n    * @since 0.6.0\n    */\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\n    /**\n    * Ray's maximum collision range of ray's field of view. Radius of {@link Raycaster.Ray#collisionRangeCircle Ray.body}.\n    *\n    * @name Raycaster.Ray#collisionRange\n    * @type {integer}\n    * @default Phaser.Math.MAX_SAFE_INTEGER\n    * @since 0.8.0\n    */\n    this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER;\n    /**\n    * If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n    *\n    * @name Raycaster.Ray#ignoreNotIntersectedRays\n    * @type {boolean}\n    * @default true\n    * @since 0.6.0\n    */\n    this.ignoreNotIntersectedRays = true;\n    /**\n    * If set true, ray's hit points will be rounded.\n    *\n    * @name Raycaster.Ray#round\n    * @type {boolean}\n    * @default false\n    * @since 0.8.1\n    */\n    this.round = false;\n    /**\n    * If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n    *\n    * @name Raycaster.Ray#autoSlice\n    * @type {boolean}\n    * @default false\n    * @since 0.8.0\n    */\n    this.autoSlice = false;\n    /**\n    * Array of intersections from last raycast representing field of view.\n    *\n    * @name Raycaster.Ray#intersections\n    * @type {object[]}\n    * @default []\n    * @since 0.8.0\n    */\n    this.intersections = [];\n    /**\n    * Array of triangles representing slices of field of view from last raycast.\n    *\n    * @name Raycaster.Ray#slicedIntersections\n    * @type {Phaser.Geom.Triangle[]}\n    * @default []\n    * @since 0.8.0\n    */\n    this.slicedIntersections = [];\n\n    /**\n    * Physics body for testing field of view collisions.\n    *\n    * @name Raycaster.Ray#body\n    * @type {object}\n    * @default undefined\n    * @since 0.8.0\n    */\n    //this.body = false;\n    /**\n    * Physics body type.\n    *\n    * @name Raycaster.Ray#bodyType\n    * @type {(bolean|'arcade'|'matter')}\n    * @default false\n    * @since 0.9.0\n    */\n    this.bodyType = false;\n\n    /**\n    * Ray casting stats.\n    *\n    * @name Raycaster.Ray#_stats\n    * @type {object}\n    * @private\n    * @since 0.10.0\n    * \n    * @property {string} method Used casting method (cast, castCircle, castCone).\n    * @property {number} rays Casted rays.\n    * @property {number} testedMappedObjects Tested mapped objects.\n    * @property {number} hitMappedObjects Hit mapped objects.\n    * @property {number} segments Tested segments.\n    * @property {number} time Casting time.\n    */\n    this._stats = {\n        method: 'cast',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    /**\n    * Ray's graphics object used for debug\n    *\n    * @name Raycaster.Ray#graphics\n    * @type {Phaser.GameObjects.Graphics}\n    * @private\n    * @since 0.10.0\n    */\n     this.graphics;\n\n    this.config(options);\n};\n\nRay.prototype = {\n    config: require('./config.js').config,\n    getStats: require('./stats.js').getStats,\n    setRay: require('./ray.js').setRay,    \n    setOrigin: require('./origin.js').setOrigin,\n    setRayRange: require('./range.js').setRayRange,\n    setAngle: require('./angle.js').setAngle,\n    setAngleDeg: require('./angle.js').setAngleDeg,\n    setCone: require('./cone.js').setCone,\n    setConeDeg: require('./cone.js').setConeDeg,\n    setDetectionRange: require('./range.js').setDetectionRange,\n    boundsInRange: require('./range.js').boundsInRange,\n    cast: require('./cast.js').cast,\n    castCircle: require('./castCircle.js').castCircle,\n    castCone: require('./castCone.js').castCone,\n    slice: require('./slice.js').slice,\n    setCollisionRange: require('./range.js').setCollisionRange,\n    enablePhysics: require('./enablePhysics.js').enablePhysics,\n    overlap: require('./overlap.js').overlap,\n    processOverlap: require('./overlap.js').processOverlap,\n    testArcadeOverlap: require('./overlap.js').testArcadeOverlap,\n    testMatterOverlap: require('./overlap.js').testMatterOverlap,\n    setCollisionCategory: require('./matter-physics-methods.js').setCollisionCategory,\n    setCollisionGroup: require('./matter-physics-methods.js').setCollisionGroup,\n    setCollidesWith: require('./matter-physics-methods.js').setCollidesWith,\n    setOnCollide: require('./matter-physics-methods.js').setOnCollide,\n    setOnCollideEnd: require('./matter-physics-methods.js').setOnCollideEnd,\n    setOnCollideActive: require('./matter-physics-methods.js').setOnCollideActive,\n    setOnCollideWith: require('./matter-physics-methods.js').setOnCollideWith,\n    drawDebug: require('./debug.js').drawDebug,\n    destroy: require('./destroy.js').destroy,\n};\n","/**\n * Set ray's position, direction (angle) and range.\n *\n * @method Raycaster.Ray#setRay\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} x - X coordinate.\n * @param {integer} y - Y coordinate.\n * @param {float} [angle] - Ray's angle in radians.\n * @param {integer} [range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setRay(x, y, angle, rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.origin.setTo(x, y);\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    this.rayRange = rayRange;\n\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange);\n    return this;\n}\n","/**\n * Slice ray's field of view represented by polygon or array of points into array of triangles.\n *\n * @method Raycaster.Ray#slice\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {(object[]|Phaser.Geom.Polygon)} [fov = {Ray#fov}] - Array of points or polygon representing field of view. If not passed, filed of view from last raycaste will be used.\n * @param {boolean} [closed = true|{Ray#fov}] - Define if field of view polygon is closed (first and last vertices sholud be connected). If fov was not passed, value depends of last type of casting.\n *\n * @return {Phaser.Geom.Triangle[]} Array of triangles representing slices of field of view.\n */\nexport function slice(intersections = this.intersections, closed = true) {\n    //if intersections is Phaser.Geom.Polygon object\n    if(!Array.isArray(intersections)) {\n        if(intersections.type === 4)\n            intersections = intersections.points;\n        else\n            return [];\n    }\n\n    if(intersections.length === 0)\n        return [];\n\n    let slices = [];\n    for(let i = 0, iLength = intersections.length - 1; i < iLength; i++) {\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[i].x, intersections[i].y, intersections[i+1].x, intersections[i+1].y));\n    }\n\n    if(closed)\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[0].x, intersections[0].y, intersections[intersections.length-1].x, intersections[intersections.length-1].y));\n\n    return slices;\n}\n","/**\r\n * Get ray statistics for last casting. Stats include\r\n * * number of casted rays,\r\n * * number of tested mapped objects,\r\n * * number of tested map segments.\r\n * * casting time\r\n *\r\n * @method Raycaster.Ray#getStats\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.0\r\n *\r\n * @return {object} Statisticss from last casting.\r\n */\r\n export function getStats() {\r\n     return this._stats;\r\n }\r\n","/**\r\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\r\n* @copyright    2021 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster class responsible for creating ray objects and managing mapped objects.\r\n * \r\n * @namespace Raycaster\r\n * @class Raycaster\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} [options] - Raycaster's configuration options. May include:\r\n * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n * @param {integer} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\r\n * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds.\r\n * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\r\n * @param {bool|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\r\n */\r\nexport function Raycaster(options) {\r\n    /**\r\n    * Plugin version.\r\n    *\r\n    * @name Raycaster#version\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.version = '0.10.3';\r\n    /**\r\n    * Raycaster's scene\r\n    *\r\n    * @name Raycaster#scene\r\n    * @type {Phaser.Scene}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.scene;\r\n    /**\r\n    * Raycaster's graphics object used for debug\r\n    *\r\n    * @name Raycaster#graphics\r\n    * @type {Phaser.GameObjects.Graphics}\r\n    * @private\r\n    * @since 0.10.0\r\n    */\r\n    this.graphics;\r\n    /**\r\n    * Raycaster's debug config\r\n    *\r\n    * @name Raycaster#debugOptions\r\n    * @type {Object}\r\n    * @since 0.10.0\r\n    * \r\n    * @property {bool} [enable = false] Enable debug mode\r\n    * @property {bool} [maps = true] - Enable maps debug\r\n    * @param {bool} [rays = true] - Enable rays debug\r\n    * @property {bool} graphics - Debug graphics options\r\n    * @property {bool|number} [graphics.ray = 0x00ff00] - Debug ray color. Set false to disable.\r\n    * @property {bool|number} [graphics.rayPoint = 0xff00ff] - Debug ray point color. Set false to disable.\r\n    * @property {bool|number} [graphics.mapPoint = 0x00ffff] - debug map point color. Set false to disable.\r\n    * @property {bool|number} [graphics.mapSegment = 0x0000ff] - Debug map segment color. Set false to disable.\r\n    * @property {bool|number} [graphics.mapBoundingBox = 0xff0000] - Debug map bounding box color. Set false to disable.\r\n    */\r\n    this.debugOptions = {\r\n        enabled: false,\r\n        maps: true,\r\n        rays: true,\r\n        graphics: {\r\n            ray: 0x00ff00,\r\n            rayPoint: 0xff00ff,\r\n            mapPoint: 0x00ffff,\r\n            mapSegment: 0x0000ff,\r\n            mapBoundingBox: 0xff0000\r\n        }\r\n    };\r\n\r\n    /**\r\n    * Raycaster statistics.\r\n    *\r\n    * @name Raycaster.Raycaster#_stats\r\n    * @type {object}\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @property {object} mappedObjects Mapped objects statistics.\r\n    * @property {number} mappedObjects.total Mapped objects total.\r\n    * @property {number} mappedObjects.static Static maps.\r\n    * @property {number} mappedObjects.dynamic Dynamic maps.\r\n    * @property {number} mappedObjects.rectangleMaps Rectangle maps.\r\n    * @property {number} mappedObjects.polygonMaps Polygon maps.\r\n    * @property {number} mappedObjects.circleMaps Circle maps.\r\n    * @property {number} mappedObjects.lineMaps Line maps.\r\n    * @property {number} mappedObjects.containerMaps Container maps.\r\n    * @property {number} mappedObjects.tilemapMaps Tilemap maps.\r\n    * @property {number} mappedObjects.matterMaps Matter body maps.\r\n    */\r\n     this._stats = {\r\n        mappedObjects: {\r\n            total: 0,\r\n            static: 0,\r\n            dynamic: 0,\r\n            rectangleMaps: 0,\r\n            polygonMaps: 0,\r\n            circleMaps: 0,\r\n            lineMaps: 0,\r\n            containerMaps: 0,\r\n            tilemapMaps: 0,\r\n            matterMaps: 0\r\n        }\r\n     };\r\n\r\n    /**\r\n    * Raycaster's bounding box. By default it's size is based on Arcade Physics / Matter physics world bounds.\r\n    * If world size will change after creation of Raycaster, bounding box needs to be updated.\r\n    *\r\n    * @name Raycaster#boundingBox\r\n    * @type {Phaser.Geom.Rectangle}\r\n    * @default false\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.boundingBox = false;\r\n    /**\r\n    * Array of mapped game objects.\r\n    *\r\n    * @name Raycaster#mappedObjects\r\n    * @type {object[]}\r\n    * @since 0.6.0\r\n    */\r\n    this.mappedObjects = [];\r\n    this.sortedPoints = [];\r\n    /**\r\n    * Number of segments of circle maps.\r\n    *\r\n    * @name Raycaster#mapSegmentCount\r\n    * @type {integer}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.mapSegmentCount = 0;\r\n\r\n    if(options !== undefined) {\r\n        if(options.boundingBox === undefined && options.scene !== undefined) {\r\n            if(options.scene.physics !== undefined)\r\n                options.boundingBox = options.scene.physics.world.bounds;\r\n            else if(options.scene.matter !== undefined) {\r\n                let walls = options.scene.matter.world.walls;\r\n\r\n                if(walls.top !== null) {\r\n                    options.boundingBox = new Phaser.Geom.Rectangle(\r\n                        walls.top.vertices[3].x,\r\n                        walls.top.vertices[3].y,\r\n                        walls.bottom.vertices[1].x - walls.top.vertices[3].x,\r\n                        walls.bottom.vertices[1].y - walls.top.vertices[3].y\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setOptions(options);\r\n\r\n        if(options.autoUpdate === undefined || options.autoUpdate)\r\n            //automatically update event\r\n            this.scene.events.on('update', this.update.bind(this));\r\n    }\r\n    else\r\n        //automatically update event\r\n        this.scene.events.on('update', this.update.bind(this));\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    /**\r\n    * Configure raycaster.\r\n    *\r\n    * @method Raycaster#setOptions\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\r\n    * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n    * @param {integer} [options.mapSegmentCount = 0] - Number of segments of circle maps.\r\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\r\n    * @param {bool|object} [options.debug] - Enable debug mode or cofigure {@link Raycaster#debugOptions debugOptions}.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n            this.graphics.setDepth(999);\r\n        }\r\n\r\n        if(options.debug !== undefined && options.debug !== false) {\r\n            this.debugOptions.enabled = true;\r\n\r\n            if(typeof options.debug === 'object')\r\n                Object.assign(this.debugOptions, options.debug);\r\n        }\r\n            \r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Set Raycatser's bounding box.\r\n    *\r\n    * @method Raycaster#setBoundingBox\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {integer} x - The X coordinate of the top left corner of bounding box.\r\n    * @param {integer} y - The Y coordinate of the top left corner of bounding box.\r\n    * @param {integer} width - The width of bounding box.\r\n    * @param {integer} height - The height of bounding box.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    /**\r\n    * Map game objects\r\n    *\r\n    * @method Raycaster#mapGameObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object|object[]} objects - Game object / matter body or array of game objects / matter bodies to map.\r\n    * @param {boolean} [dynamic = false] - {@link Raycaster.Map Raycaster.Map} dynamic flag (determines map will be updated automatically).\r\n    * @param {object} [options] - Additional options for {@link Raycaster.Map Raycaster.Map}\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    mapGameObjects: function(objects, dynamic = false, options = {}) {\r\n        options.dynamic = dynamic;\r\n        options.segmentCount = (options.segmentCount !== undefined) ? options.segmentCount : this.segmentCount;\r\n\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            let config = {};\r\n            for(let option in options) {\r\n                config[option] = options[option];\r\n            }\r\n            config.object = object;\r\n            \r\n            let map = new this.Map(config, this);\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                object.raycasterMap = map;\r\n            }\r\n            else if(!object.data) {\r\n                object.setDataEnabled();\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n            else {\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n\r\n            this.mappedObjects.push(object);\r\n\r\n            //update stats\r\n            if(object.dynamic)\r\n                this._stats.mappedObjects.dynamic++;\r\n            else\r\n                this._stats.mappedObjects.static++;\r\n            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps++;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps++;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps++;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps++;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps++;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps++;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Remove game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#removeMappedObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be removed.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n\r\n        for(let object of objects) {\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1);\r\n            \r\n            if(object.type === 'body' || object.type === 'composite')\r\n                object.raycasterMap.destroy();\r\n            else\r\n                object.data.get('raycasterMap').destroy();\r\n            \r\n            //update stats\r\n            if(object.dynamic)\r\n                this._stats.mappedObjects.dynamic--;\r\n            else\r\n                this._stats.mappedObjects.static--;\r\n            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps--;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps--;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps--;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps--;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps--;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps--;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Enable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#enableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be enabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    enableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Disable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#disableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be disabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    disableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Updates all {@link Raycaster.Map Raycaster.Map} dynamic maps. Fired on Phaser.Scene update event.\r\n    *\r\n    * @method Raycaster#update\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    update: function() {\r\n        //update dynamic maps\r\n        let dynamicMaps = 0;\r\n        if(this.mappedObjects.length > 0) {\r\n            for(let mapppedObject of this.mappedObjects) {\r\n                let map;\r\n\r\n                if(mapppedObject.type === 'body' || mapppedObject.type === 'composite') {\r\n                    map = mapppedObject.raycasterMap;\r\n                }\r\n                else if(mapppedObject.data) {\r\n                    map = mapppedObject.data.get('raycasterMap');\r\n                }\r\n\r\n                if(!map)\r\n                    continue;\r\n\r\n                if(map.dynamic) {\r\n                    map.updateMap();\r\n                    dynamicMaps++;\r\n                }\r\n            }\r\n\r\n            //update stats\r\n            this._stats.mappedObjects.static = this.mappedObjects.length - dynamicMaps;\r\n            this._stats.mappedObjects.dynamic = dynamicMaps;\r\n\r\n            //debug\r\n            if(this.debugOptions.enabled)\r\n                this.drawDebug();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Create {@link Raycaster.Ray Raycaster.Ray} object.\r\n    *\r\n    * @method Raycaster#createRay\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Ray options:\r\n    *\r\n    * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n    */\r\n    createRay: function(options = {}) {\r\n        return new this.Ray(options, this);\r\n    },\r\n\r\n    /**\r\n    * Get raycaster statistics.\r\n    *\r\n    * @method Raycaster#getStats\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.10.0\r\n    *\r\n    * @return {object} Raycaster statistics.\r\n    */\r\n    getStats: function() {\r\n        return this._stats;\r\n    },\r\n\r\n    /**\r\n    * Draw maps in debug mode\r\n    *\r\n    * @method Raycaster#drawDebug\r\n    * @memberof Raycaster\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n     drawDebug: function() {\r\n        if(this.graphics === undefined || !this.debugOptions.enabled)\r\n            return this;\r\n\r\n        //clear\r\n        this.graphics.clear();\r\n\r\n        if(!this.debugOptions.maps)\r\n            return this;\r\n\r\n        for(let object of this.mappedObjects)\r\n        {\r\n            let map;\r\n        \r\n            if(object.type === 'body' || object.type === 'composite')\r\n                map = object.raycasterMap;\r\n            else\r\n                map = object.data.get('raycasterMap');\r\n            \r\n            if(!map)\r\n                continue;\r\n\r\n            //draw bounding box\r\n            if(this.debugOptions.graphics.mapBoundingBox) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapBoundingBox);\r\n                this.graphics.strokeRectShape(map.getBoundingBox());\r\n            }\r\n\r\n            //draw segments\r\n            if(this.debugOptions.graphics.mapSegment) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapSegment);\r\n                for(let segment of map.getSegments()) {\r\n                    this.graphics.strokeLineShape(segment);\r\n                }\r\n            }\r\n\r\n            //draw points\r\n            if(this.debugOptions.graphics.mapPoint) {\r\n                this.graphics.fillStyle(this.debugOptions.graphics.mapPoint);\r\n                for(let point of map.getPoints()) {\r\n                    this.graphics.fillPoint(point.x, point.y, 3)\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Destroy object and all mapped objects.\r\n     *\r\n     * @method Raycaster#destroy\r\n     * @memberof Raycaster\r\n     * @instance\r\n     * @since 0.10.3\r\n     */\r\n    destroy: function() {\r\n        this.removeMappedObjects(this.mappedObjects);\r\n\r\n        for(let key in this) {\r\n            delete this[key];\r\n        }\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(880);\n"],"names":["root","factory","exports","module","define","amd","self","PhaserRaycaster","scene","this","systems","sys","settings","isBooted","events","once","boot","register","PluginManager","prototype","eventEmitter","on","start","preUpdate","update","postUpdate","pause","resume","sleep","wake","shutdown","destroy","test","name","console","log","time","delta","undefined","createRaycaster","options","_Raycaster","constructor","require","getBoundingBox","object","getBounds","rectangle","line","polygon","arc","container","tilemap","matterBody","segmentCount","boundingBox","config","type","getPoints","getSegments","updateMap","circle","setSegmentCount","mapChild","_circles","_updateChildMap","collisionTiles","setCollisionTiles","setOrigin","forceConvex","forceVerticesMapping","dynamic","active","key","raycasterMap","data","remove","ray","_points","length","points","offset","Phaser","Geom","Point","x","displayWidth","originX","y","displayHeight","originY","c","rayA","Line","rayB","rotation","vector","SetToAngle","Angle","Length","cB","getPointB","origin","rayLength","Math","sqrt","pow","radius","scaleX","angle","dAngle","asin","push","_segments","scaleY","geom","segments","newPoints","point","i","isChild","_raycaster","createRay","iterate","child","bind","iLength","list","childA","mapA","get","j","jLength","childB","mapB","Intersects","RectangleToRectangle","segmentA","segmentB","intersection","LineToLine","setDataEnabled","map","set","childPoints","segment","pointA","getPointA","pointB","vectorA","vectorB","circleOffset","Circle","childMapCircle","Map","raycaster","body","circleRadius","position","scale","bodies","generateBounds","bounds","bodyItem","parts","vertices","find","segmentIndex","findIndex","x1","y1","x2","y2","splice","closingSegment","matter","composite","Rectangle","min","max","closePath","last","getTopLeft","getTopRight","getBottomRight","getBottomLeft","detectionRange","MAX_SAFE_INTEGER","Distance","Between","LineToCircle","detectionRangeCircle","horizontal","horizontals","verticals","layer","row","tile","upperEdge","includes","index","leftEdge","vertical","height","width","tileWidth","tileHeight","verticalsLastColumn","column","filter","horizontalSegment","tiles","count","setAngle","Normalize","_ray","rayRange","setAngleDeg","DegToRad","cast","closestIntersection","closestSegment","closestObject","closestDistance","internal","startTime","performance","now","stats","method","rays","testedMappedObjects","hitMappedObjects","intersections","GetLineToRectangle","distance","target","objects","mappedObjects","result","_boundingBox","setTo","Equals","isTangent","circleIntersections","GetLineToCircle","_stats","ignoreNotIntersectedRays","round","drawDebug","castCircle","originalAngle","maps","rayTargets","testedObjects","boundsInRange","objectB","sort","a","b","previousTarget","castSides","roundedTarget","intersectionA","intersectionB","autoSlice","slicedIntersections","slice","castCone","cone","minAngle","maxAngle","coneDeg","angleOffsetDeg","RadToDeg","ShortestBetween","abs","setCone","setConeDeg","angleDeg","collisionRange","enablePhysics","debugOptions","enabled","graphics","add","lineStyle","color","fillStyle","setDepth","clear","strokeLineShape","rayPoint","fillPoint","collisionCircle","bodyType","gameObject","shape","centerX","centerY","label","isSensor","ignoreGravity","setOnCollideActive","physics","existing","setCircle","setAllowGravity","setImmovable","setCollisionCategory","value","collisionFilter","category","setCollisionGroup","group","setCollidesWith","categories","flags","Array","isArray","mask","setOnCollide","callback","onCollideCallback","collisionInfo","rayCollided","processOverlap","setOnCollideEnd","onCollideEndCallback","onCollideActiveCallback","bodyA","bodyB","onCollideWith","id","setOnCollideWith","func","src","hasOwnProperty","overlap","targets","overlapCircle","query","collides","getMatterBodies","testMatterOverlap","overlapCirc","hitbox","isCircle","halfWidth","testArcadeOverlap","CircleToCircle","CircleToRectangle","object1","object2","obj1","obj2","TriangleToCircle","RectangleToTriangle","part","TriangleToLine","Triangle","ContainsPoint","setRayRange","setDetectionRange","setCollisionRange","oldRangeMax","setRadius","isStatic","objectBounds","Ray","getStats","setRay","closed","slices","Raycaster","version","mapPoint","mapSegment","mapBoundingBox","total","static","rectangleMaps","polygonMaps","circleMaps","lineMaps","containerMaps","tilemapMaps","matterMaps","sortedPoints","mapSegmentCount","world","walls","top","bottom","setOptions","autoUpdate","debug","Object","assign","mapGameObjects","setBoundingBox","left","right","option","removeMappedObjects","indexOf","enableMaps","disableMaps","dynamicMaps","mapppedObject","strokeRectShape","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","d","definition","o","defineProperty","enumerable","obj","prop","call","r","Symbol","toStringTag"],"sourceRoot":""}